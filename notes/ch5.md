### p108 wait/waitpid

Q: `waitpid()` 中，为什么要用 `while` 循环，且为什么要用 `waitpid` 的非阻塞模式(`option=WNOHANG`)？

1. 用 `while` 循环
   如果在信号处理函数中，有子进程终止，可以通过 `while` 循环一次性回收。也就是说不用 `while` 也是可以的，只是每一次收到 `SIGCHLD` 信号后，只能回收一个子进程。

2. 非阻塞模式
   保证在回收最后一个终止的子进程后，没有子进程退出时，waitpid出错返回，从而从信号处理函数中跳出而不是阻塞在信号处理函数中。



`waitpid` 与 `wait` 的区别：

- 进程一旦调用了 `wait` ，就立即阻塞自己，由 `wait` 自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程， `wait` 就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程， `wait` 就会一直阻塞在这里，直到有一个出现为止。

- 当 `waitpid` 的第三个参数 `options` 置为 `WNOHANG` 时，如果发现没有已退出的子进程可收集，则返回 `0` ，不会像wait那样永远等下去。

- `wait` 等于一个 `waitpid` 的特例：`wait(statlic) = waitpid(-1, statloc, 0)`

- 注意：使用 `wait/waitpid` 的前提是父进程晚于子进程退出。
